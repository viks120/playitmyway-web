<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2048 Slider - Play It My Way</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Arial", sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
      }

      .header {
        text-align: center;
        color: white;
        margin-bottom: 30px;
      }

      .header h1 {
        font-size: 3rem;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .score-container {
        display: flex;
        gap: 20px;
        margin-bottom: 20px;
      }

      .score-box {
        background: rgba(255, 255, 255, 0.9);
        padding: 15px 25px;
        border-radius: 10px;
        text-align: center;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      }

      .score-label {
        font-size: 0.9rem;
        color: #666;
        margin-bottom: 5px;
      }

      .score-value {
        font-size: 1.5rem;
        font-weight: bold;
        color: #333;
      }

      .game-container {
        background: rgba(255, 255, 255, 0.95);
        padding: 20px;
        border-radius: 15px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        margin-bottom: 20px;
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 10px;
        background: #bbada0;
        padding: 10px;
        border-radius: 10px;
      }

      .cell {
        width: 80px;
        height: 80px;
        background: #cdc1b4;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.8rem;
        font-weight: bold;
        color: #776e65;
        transition: all 0.15s ease;
        position: relative;
      }

      .cell[data-value="2"] {
        background: #eee4da;
      }
      .cell[data-value="4"] {
        background: #ede0c8;
      }
      .cell[data-value="8"] {
        background: #f2b179;
        color: #f9f6f2;
      }
      .cell[data-value="16"] {
        background: #f59563;
        color: #f9f6f2;
      }
      .cell[data-value="32"] {
        background: #f67c5f;
        color: #f9f6f2;
      }
      .cell[data-value="64"] {
        background: #f65e3b;
        color: #f9f6f2;
      }
      .cell[data-value="128"] {
        background: #edcf72;
        color: #f9f6f2;
        font-size: 1.6rem;
      }
      .cell[data-value="256"] {
        background: #edcc61;
        color: #f9f6f2;
        font-size: 1.6rem;
      }
      .cell[data-value="512"] {
        background: #edc850;
        color: #f9f6f2;
        font-size: 1.6rem;
      }
      .cell[data-value="1024"] {
        background: #edc53f;
        color: #f9f6f2;
        font-size: 1.4rem;
      }
      .cell[data-value="2048"] {
        background: #edc22e;
        color: #f9f6f2;
        font-size: 1.4rem;
      }

      .cell.new {
        animation: pop 0.3s ease;
      }

      .cell.merged {
        animation: merge 0.3s ease;
      }

      @keyframes pop {
        0% {
          transform: scale(0);
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
        }
      }

      @keyframes merge {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.2);
        }
        100% {
          transform: scale(1);
        }
      }

      .controls {
        text-align: center;
        margin-bottom: 20px;
      }

      .btn {
        background: #8f7a66;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 1rem;
        cursor: pointer;
        margin: 0 10px;
        transition: all 0.3s ease;
      }

      .btn:hover {
        background: #7f6a56;
        transform: translateY(-2px);
      }

      .game-over {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }

      .game-over.show {
        display: flex;
      }

      .game-over-content {
        background: white;
        padding: 40px;
        border-radius: 15px;
        text-align: center;
        max-width: 400px;
        animation: scaleIn 0.3s ease;
      }

      .game-over h2 {
        color: #333;
        margin-bottom: 20px;
        font-size: 2em;
      }

      .game-over p {
        color: #666;
        margin-bottom: 25px;
        font-size: 1.2em;
      }

      .stars {
        font-size: 2.5em;
        margin: 15px 0;
      }

      .star {
        color: #ddd;
        transition: color 0.3s;
      }

      .star.filled {
        color: #ffd700;
      }

      .high-score-msg {
        color: #ff6b6b;
        font-weight: bold;
        font-size: 1.2em;
        margin-bottom: 15px;
      }

      /* Confetti */
      .confetti {
        position: fixed;
        width: 10px;
        height: 10px;
        top: -10px;
        z-index: 1001;
        animation: confettiFall 3s linear forwards;
      }

      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }

      @keyframes scaleIn {
        from { transform: scale(0.8); opacity: 0; }
        to { transform: scale(1); opacity: 1; }
      }

      @keyframes confettiFall {
        0% { transform: translateY(0) rotate(0deg); opacity: 1; }
        100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
      }

      .back-link {
        position: fixed;
        top: 20px;
        left: 20px;
        background: rgba(255, 255, 255, 0.9);
        color: #333;
        text-decoration: none;
        padding: 10px 15px;
        border-radius: 8px;
        font-weight: bold;
        transition: all 0.3s ease;
        z-index: 100;
      }

      .back-link:hover {
        background: white;
        transform: translateY(-2px);
      }

      @media (max-width: 600px) {
        .cell {
          width: 60px;
          height: 60px;
          font-size: 1.4rem;
        }

        .header h1 {
          font-size: 2rem;
        }

        .score-container {
          flex-direction: column;
          gap: 10px;
        }
      }
    </style>
  </head>
  <body>
    <a href="../../index.html" class="back-link">‚Üê Back to Games</a>

    <div class="header">
      <h1>2048</h1>
      <p>Slide tiles to reach 2048!</p>
    </div>

    <div class="score-container">
      <div class="score-box">
        <div class="score-label">Score</div>
        <div class="score-value" id="score">0</div>
      </div>
      <div class="score-box">
        <div class="score-label">Best</div>
        <div class="score-value" id="best">0</div>
      </div>
    </div>

    <div class="controls">
      <button class="btn" onclick="newGame()">New Game</button>
      <button class="btn" onclick="showInstructions()">How to Play</button>
    </div>

    <div class="game-container">
      <div class="grid" id="grid"></div>
    </div>

    <div class="game-over" id="gameOver">
      <div class="game-over-content">
        <h2 id="gameOverTitle">Game Over!</h2>
        <div class="stars" id="starRating">
          <span class="star">‚òÖ</span>
          <span class="star">‚òÖ</span>
          <span class="star">‚òÖ</span>
        </div>
        <p id="gameOverMessage">
          Your final score: <span id="finalScore">0</span>
        </p>
        <p id="highScoreMsg" class="high-score-msg" style="display: none;">üèÜ New High Score!</p>
        <button class="btn" onclick="newGame()">Play Again</button>
      </div>
    </div>

    <script>
      // Sound effects using Web Audio API
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      let audioCtx = null;

      function initAudio() {
        if (!audioCtx) {
          audioCtx = new AudioContext();
        }
      }

      function playSound(type) {
        initAudio();
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        switch(type) {
          case 'move':
            oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
            oscillator.type = 'sine';
            gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.05);
            break;
          case 'merge':
            oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
            oscillator.frequency.setValueAtTime(500, audioCtx.currentTime + 0.05);
            oscillator.type = 'sine';
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.1);
            break;
          case 'win':
            const winNotes = [523, 659, 784, 1047];
            winNotes.forEach((freq, i) => {
              const osc = audioCtx.createOscillator();
              const gain = audioCtx.createGain();
              osc.connect(gain);
              gain.connect(audioCtx.destination);
              osc.frequency.setValueAtTime(freq, audioCtx.currentTime + i * 0.15);
              osc.type = 'sine';
              gain.gain.setValueAtTime(0.15, audioCtx.currentTime + i * 0.15);
              gain.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + i * 0.15 + 0.3);
              osc.start(audioCtx.currentTime + i * 0.15);
              osc.stop(audioCtx.currentTime + i * 0.15 + 0.3);
            });
            return;
          case 'gameOver':
            oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
            oscillator.frequency.setValueAtTime(200, audioCtx.currentTime + 0.2);
            oscillator.frequency.setValueAtTime(150, audioCtx.currentTime + 0.4);
            oscillator.type = 'sine';
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.6);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.6);
            break;
        }
      }

      function createConfetti() {
        const colors = ['#ff6b6b', '#4ecdc4', '#ffd700', '#a8e6cf', '#ff9ff3', '#54a0ff'];
        for (let i = 0; i < 50; i++) {
          const confetti = document.createElement('div');
          confetti.className = 'confetti';
          confetti.style.left = Math.random() * 100 + 'vw';
          confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
          confetti.style.animationDelay = Math.random() * 2 + 's';
          confetti.style.animationDuration = (Math.random() * 2 + 2) + 's';
          document.body.appendChild(confetti);
          setTimeout(() => confetti.remove(), 5000);
        }
      }

      function displayStars(score) {
        const stars = document.querySelectorAll('#starRating .star');
        const starCount = score >= 10000 ? 3 : score >= 5000 ? 2 : 1;
        stars.forEach((star, i) => {
          star.classList.toggle('filled', i < starCount);
        });
      }

      class Game2048 {
        constructor() {
          this.grid = Array(4)
            .fill()
            .map(() => Array(4).fill(0));
          this.score = 0;
          this.best = parseInt(localStorage.getItem("2048-best")) || 0;
          this.gameOver = false;
          this.eventListenersAdded = false;
          this.init();
        }

        init() {
          this.updateBest();
          this.addRandomTile();
          this.addRandomTile();
          this.render();
          if (!this.eventListenersAdded) {
            this.setupEventListeners();
            this.eventListenersAdded = true;
          }
        }

        setupEventListeners() {
          document.addEventListener("keydown", (e) => {
            if (this.gameOver) return;

            switch (e.key) {
              case "ArrowUp":
                e.preventDefault();
                this.move("up");
                break;
              case "ArrowDown":
                e.preventDefault();
                this.move("down");
                break;
              case "ArrowLeft":
                e.preventDefault();
                this.move("left");
                break;
              case "ArrowRight":
                e.preventDefault();
                this.move("right");
                break;
            }
          });

          // Touch events for mobile
          let startX, startY;
          const minSwipeDistance = 30; // Minimum distance for a swipe

          document.addEventListener("touchstart", (e) => {
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
          });

          document.addEventListener("touchend", (e) => {
            if (!startX || !startY || this.gameOver) return;

            const endX = e.changedTouches[0].clientX;
            const endY = e.changedTouches[0].clientY;

            const diffX = startX - endX;
            const diffY = startY - endY;

            // Only register swipe if it's longer than minimum distance
            if (Math.abs(diffX) < minSwipeDistance && Math.abs(diffY) < minSwipeDistance) {
              startX = startY = null;
              return;
            }

            if (Math.abs(diffX) > Math.abs(diffY)) {
              if (diffX > 0) this.move("left");
              else this.move("right");
            } else {
              if (diffY > 0) this.move("up");
              else this.move("down");
            }

            startX = startY = null;
          });
        }

        addRandomTile() {
          const emptyCells = [];
          for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 4; j++) {
              if (this.grid[i][j] === 0) {
                emptyCells.push({ i, j });
              }
            }
          }

          if (emptyCells.length > 0) {
            const { i, j } =
              emptyCells[Math.floor(Math.random() * emptyCells.length)];
            this.grid[i][j] = Math.random() < 0.9 ? 2 : 4;
          }
        }

        move(direction) {
          const oldGrid = JSON.stringify(this.grid);
          let moved = false;

          switch (direction) {
            case "left":
              moved = this.moveLeft();
              break;
            case "right":
              moved = this.moveRight();
              break;
            case "up":
              moved = this.moveUp();
              break;
            case "down":
              moved = this.moveDown();
              break;
          }

          if (moved) {
            playSound('move');
            this.addRandomTile();
            this.render();
            this.checkGameOver();
          }
        }

        moveLeft() {
          let moved = false;
          for (let i = 0; i < 4; i++) {
            const row = this.grid[i].filter((x) => x !== 0);
            for (let j = 0; j < row.length - 1; j++) {
              if (row[j] === row[j + 1]) {
                row[j] *= 2;
                this.score += row[j];
                row.splice(j + 1, 1);
                moved = true;
              }
            }
            const newRow = row.concat(Array(4 - row.length).fill(0));
            if (JSON.stringify(this.grid[i]) !== JSON.stringify(newRow)) {
              moved = true;
            }
            this.grid[i] = newRow;
          }
          return moved;
        }

        moveRight() {
          let moved = false;
          for (let i = 0; i < 4; i++) {
            const row = this.grid[i].filter((x) => x !== 0);
            for (let j = row.length - 1; j > 0; j--) {
              if (row[j] === row[j - 1]) {
                row[j] *= 2;
                this.score += row[j];
                row.splice(j - 1, 1);
                moved = true;
              }
            }
            const newRow = Array(4 - row.length)
              .fill(0)
              .concat(row);
            if (JSON.stringify(this.grid[i]) !== JSON.stringify(newRow)) {
              moved = true;
            }
            this.grid[i] = newRow;
          }
          return moved;
        }

        moveUp() {
          let moved = false;
          for (let j = 0; j < 4; j++) {
            const col = [];
            for (let i = 0; i < 4; i++) {
              if (this.grid[i][j] !== 0) col.push(this.grid[i][j]);
            }
            for (let i = 0; i < col.length - 1; i++) {
              if (col[i] === col[i + 1]) {
                col[i] *= 2;
                this.score += col[i];
                col.splice(i + 1, 1);
                moved = true;
              }
            }
            const newCol = col.concat(Array(4 - col.length).fill(0));
            for (let i = 0; i < 4; i++) {
              if (this.grid[i][j] !== newCol[i]) {
                moved = true;
              }
              this.grid[i][j] = newCol[i];
            }
          }
          return moved;
        }

        moveDown() {
          let moved = false;
          for (let j = 0; j < 4; j++) {
            const col = [];
            for (let i = 0; i < 4; i++) {
              if (this.grid[i][j] !== 0) col.push(this.grid[i][j]);
            }
            for (let i = col.length - 1; i > 0; i--) {
              if (col[i] === col[i - 1]) {
                col[i] *= 2;
                this.score += col[i];
                col.splice(i - 1, 1);
                moved = true;
              }
            }
            const newCol = Array(4 - col.length)
              .fill(0)
              .concat(col);
            for (let i = 0; i < 4; i++) {
              if (this.grid[i][j] !== newCol[i]) {
                moved = true;
              }
              this.grid[i][j] = newCol[i];
            }
          }
          return moved;
        }

        render() {
          const gridElement = document.getElementById("grid");
          gridElement.innerHTML = "";

          for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 4; j++) {
              const cell = document.createElement("div");
              cell.className = "cell";
              const value = this.grid[i][j];

              if (value !== 0) {
                cell.textContent = value;
                cell.setAttribute("data-value", value);
              }

              gridElement.appendChild(cell);
            }
          }

          document.getElementById("score").textContent = this.score;
          this.updateBest();
        }

        updateBest() {
          if (this.score > this.best) {
            this.best = this.score;
            localStorage.setItem("2048-best", this.best);
          }
          document.getElementById("best").textContent = this.best;
        }

        checkGameOver() {
          // Check if 2048 is reached
          for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 4; j++) {
              if (this.grid[i][j] === 2048) {
                this.showGameOver(
                  "You Win!",
                  "Congratulations! You reached 2048!"
                );
                return;
              }
            }
          }

          // Check if no moves are possible
          if (!this.canMove()) {
            this.showGameOver("Game Over!", "No more moves possible!");
          }
        }

        canMove() {
          // Check for empty cells
          for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 4; j++) {
              if (this.grid[i][j] === 0) return true;
            }
          }

          // Check for possible merges
          for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 4; j++) {
              const current = this.grid[i][j];
              if (j < 3 && this.grid[i][j + 1] === current) return true;
              if (i < 3 && this.grid[i + 1][j] === current) return true;
            }
          }

          return false;
        }

        showGameOver(title, message) {
          this.gameOver = true;
          document.getElementById("gameOverTitle").textContent = title;
          document.getElementById("gameOverMessage").innerHTML = `Your final score: <span id="finalScore">${this.score}</span>`;
          
          displayStars(this.score);
          
          // Check for new high score (must be strictly greater than previous best)
          const previousBest = parseInt(localStorage.getItem("2048-best")) || 0;
          const highScoreMsg = document.getElementById("highScoreMsg");
          if (this.score > previousBest && this.score > 0) {
            highScoreMsg.style.display = "block";
          } else {
            highScoreMsg.style.display = "none";
          }
          
          document.getElementById("gameOver").classList.add("show");
          
          if (title === "You Win!") {
            playSound('win');
            createConfetti();
          } else {
            playSound('gameOver');
          }
        }

        reset() {
          this.grid = Array(4)
            .fill()
            .map(() => Array(4).fill(0));
          this.score = 0;
          this.gameOver = false;
          document.getElementById("gameOver").classList.remove("show");
          this.init();
        }
      }

      let game;

      function newGame() {
        if (game) {
          game.reset();
        } else {
          game = new Game2048();
        }
      }

      function showInstructions() {
        alert(`How to play 2048:

‚Ä¢ Use arrow keys or swipe to move tiles
‚Ä¢ Tiles with the same number merge when they touch
‚Ä¢ Try to reach the 2048 tile!
‚Ä¢ Game ends when no more moves are possible

Good luck!`);
      }

      // Initialize game when page loads
      window.addEventListener("load", () => {
        game = new Game2048();
      });
    </script>
  </body>
</html>
