<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#1a5276">
  <title>Free Sudoku Game Online | Play It My Way</title>
  <meta name="description" content="Play Sudoku online for free! Easy, Medium, Hard levels. Train your brain with this classic number puzzle. No download required!">
  <style>
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    body {
      font-family: "Comic Sans MS", "Arial Rounded MT Bold", Arial, sans-serif;
      background: linear-gradient(135deg, #1a5276 0%, #2980b9 100%);
      margin: 0; padding: 10px; min-height: 100vh;
      display: flex; flex-direction: column; align-items: center;
    }
    .back-link {
      position: absolute; top: 15px; left: 15px; color: white;
      text-decoration: none; font-size: 1em;
      background: rgba(255,255,255,0.2); padding: 8px 12px;
      border-radius: 20px; z-index: 100;
    }
    .back-link:hover { background: rgba(255,255,255,0.3); }
    .header { text-align: center; color: white; margin-bottom: 15px; }
    .header h1 { font-size: clamp(1.5em, 5vw, 2em); margin: 0; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
    .stats {
      display: flex; gap: 20px; margin-bottom: 15px; color: white;
      font-size: 1.1em; font-weight: bold; flex-wrap: wrap; justify-content: center;
    }
    .difficulty-selector { margin-bottom: 15px; }
    .diff-btn {
      background: linear-gradient(45deg, #e74c3c, #c0392b); color: white;
      border: none; padding: 8px 18px; border-radius: 20px;
      font-size: 1em; font-weight: bold; cursor: pointer; margin: 3px;
    }
    .diff-btn.active { background: linear-gradient(45deg, #27ae60, #2ecc71); transform: scale(1.05); }
    .game-container {
      background: rgba(255,255,255,0.95); border-radius: 15px;
      padding: 20px; box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }
    .grid {
      display: grid; grid-template-columns: repeat(9, 1fr);
      gap: 0; margin: 0 auto; border: 3px solid #2c3e50;
      width: min(360px, 90vw); height: min(360px, 90vw);
    }
    .cell {
      aspect-ratio: 1; background: white; display: flex;
      align-items: center; justify-content: center;
      font-size: clamp(16px, 4vw, 24px); font-weight: bold;
      cursor: pointer; border: 1px solid #bdc3c7; position: relative;
    }
    .cell:nth-child(3n) { border-right: 2px solid #2c3e50; }
    .cell:nth-child(n+19):nth-child(-n+27),
    .cell:nth-child(n+46):nth-child(-n+54) { border-bottom: 2px solid #2c3e50; }
    .cell.given { background: #ecf0f1; color: #2c3e50; }
    .cell.selected { background: #aed6f1; }
    .cell.same-num { background: #d5f5e3; }
    .cell.error { background: #f5b7b1; }
    .cell.user-input { color: #2980b9; }
    .num-pad {
      display: grid; grid-template-columns: repeat(5, 1fr);
      gap: 8px; margin-top: 15px; max-width: 300px; margin-left: auto; margin-right: auto;
    }
    .num-btn {
      padding: 12px; font-size: 1.3em; font-weight: bold;
      border: none; border-radius: 10px; cursor: pointer;
      background: linear-gradient(45deg, #3498db, #2980b9); color: white;
    }
    .num-btn:hover { transform: scale(1.05); }
    .num-btn.erase { background: linear-gradient(45deg, #e74c3c, #c0392b); }
    .controls { margin-top: 15px; text-align: center; }
    .btn {
      background: linear-gradient(45deg, #9b59b6, #8e44ad); color: white;
      border: none; padding: 10px 20px; border-radius: 25px;
      font-size: 1em; font-weight: bold; cursor: pointer; margin: 5px;
    }
    .btn:hover { transform: scale(1.05); }
    .modal-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.7); display: none;
      justify-content: center; align-items: center; z-index: 1000;
    }
    .modal-overlay.show { display: flex; }
    .modal {
      background: white; border-radius: 20px; padding: 30px;
      text-align: center; max-width: 350px; width: 90%;
    }
    .modal h2 { font-size: 1.8em; margin-bottom: 10px; }
    .modal p { font-size: 1.2em; color: #666; }
    .modal-btn {
      background: linear-gradient(45deg, #27ae60, #2ecc71); color: white;
      border: none; padding: 12px 25px; border-radius: 25px;
      font-size: 1.1em; font-weight: bold; cursor: pointer; margin: 5px;
    }
    .stars { font-size: 2.5em; margin: 10px 0; }
    .star { color: #ddd; }
    .star.filled { color: #f1c40f; }
    .confetti {
      position: fixed; width: 10px; height: 10px; top: -10px; z-index: 1001;
      animation: confettiFall 3s linear forwards;
    }
    @keyframes confettiFall {
      0% { transform: translateY(0) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
    }
    @media (max-width: 400px) {
      .back-link { top: 5px; left: 5px; padding: 5px 8px; font-size: 0.8em; }
      .game-container { padding: 10px; }
      .num-pad { gap: 5px; }
      .num-btn { padding: 10px; font-size: 1.1em; }
    }
  </style>
</head>
<body>
  <a href="../../" class="back-link">‚Üê Back to Games</a>
  <div class="header"><h1>üî¢ Sudoku</h1></div>
  <div class="stats">
    <div>‚è±Ô∏è Time: <span id="timer">0:00</span></div>
    <div>‚ùå Errors: <span id="errors">0</span>/3</div>
    <div>üèÜ Best: <span id="best">-</span></div>
  </div>
  <div class="difficulty-selector">
    <button class="diff-btn active" onclick="setDifficulty('easy')">üå± Easy</button>
    <button class="diff-btn" onclick="setDifficulty('medium')">üåø Medium</button>
    <button class="diff-btn" onclick="setDifficulty('hard')">üå≥ Hard</button>
  </div>
  <div class="game-container">
    <div class="grid" id="grid"></div>
    <div class="num-pad" id="numPad"></div>
    <div class="controls">
      <button class="btn" onclick="newGame()">üîÑ New Game</button>
      <button class="btn" onclick="getHint()">üí° Hint</button>
    </div>
  </div>
  <div class="modal-overlay" id="modal">
    <div class="modal">
      <h2 id="modalTitle">üéâ Congratulations!</h2>
      <div class="stars" id="starRating"><span class="star">‚òÖ</span><span class="star">‚òÖ</span><span class="star">‚òÖ</span></div>
      <p id="modalMsg">You solved the puzzle!</p>
      <button class="modal-btn" onclick="closeModal()">Play Again</button>
    </div>
  </div>
  <script>

    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx = null;
    function initAudio() { if (!audioCtx) audioCtx = new AudioContext(); }
    function playSound(type) {
      initAudio();
      if (type === 'place') {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.frequency.setValueAtTime(500, audioCtx.currentTime);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        osc.start(); osc.stop(audioCtx.currentTime + 0.1);
      } else if (type === 'error') {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.type = 'square';
        osc.frequency.setValueAtTime(200, audioCtx.currentTime);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
        osc.start(); osc.stop(audioCtx.currentTime + 0.2);
      } else if (type === 'win') {
        [523, 659, 784, 1047].forEach((f, i) => {
          const o = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          o.connect(g); g.connect(audioCtx.destination);
          o.frequency.setValueAtTime(f, audioCtx.currentTime + i * 0.12);
          g.gain.setValueAtTime(0.1, audioCtx.currentTime + i * 0.12);
          g.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + i * 0.12 + 0.2);
          o.start(audioCtx.currentTime + i * 0.12);
          o.stop(audioCtx.currentTime + i * 0.12 + 0.2);
        });
      }
    }
    function createConfetti() {
      const colors = ['#e74c3c', '#3498db', '#f1c40f', '#2ecc71', '#9b59b6'];
      for (let i = 0; i < 40; i++) {
        const c = document.createElement('div');
        c.className = 'confetti';
        c.style.left = Math.random() * 100 + 'vw';
        c.style.background = colors[Math.floor(Math.random() * colors.length)];
        c.style.animationDelay = Math.random() * 1.5 + 's';
        document.body.appendChild(c);
        setTimeout(() => c.remove(), 4000);
      }
    }

    let difficulty = 'easy';
    let board = [], solution = [], given = [];
    let selectedCell = null, errors = 0, gameOver = false;
    let timerInterval, seconds = 0;
    let best = JSON.parse(localStorage.getItem('sudoku_best') || '{}');

    const removeCounts = { easy: 35, medium: 45, hard: 55 };

    function setDifficulty(d) {
      difficulty = d;
      document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
      event.target.classList.add('active');
      newGame();
    }

    function generateSudoku() {
      // Create empty grid
      const grid = Array(9).fill(null).map(() => Array(9).fill(0));
      
      // Fill grid using backtracking with randomization
      fillGrid(grid);
      return grid;
    }

    function fillGrid(grid) {
      const empty = findEmpty(grid);
      if (!empty) return true; // Grid is complete
      
      const [row, col] = empty;
      const nums = shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9]);
      
      for (const num of nums) {
        if (isValid(grid, row, col, num)) {
          grid[row][col] = num;
          if (fillGrid(grid)) return true;
          grid[row][col] = 0;
        }
      }
      return false;
    }

    function findEmpty(grid) {
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          if (grid[r][c] === 0) return [r, c];
        }
      }
      return null;
    }

    function isValid(grid, row, col, num) {
      // Check row
      for (let c = 0; c < 9; c++) {
        if (grid[row][c] === num) return false;
      }
      // Check column
      for (let r = 0; r < 9; r++) {
        if (grid[r][col] === num) return false;
      }
      // Check 3x3 box
      const boxRow = Math.floor(row / 3) * 3;
      const boxCol = Math.floor(col / 3) * 3;
      for (let r = boxRow; r < boxRow + 3; r++) {
        for (let c = boxCol; c < boxCol + 3; c++) {
          if (grid[r][c] === num) return false;
        }
      }
      return true;
    }

    function countSolutions(grid, limit = 2) {
      const empty = findEmpty(grid);
      if (!empty) return 1;
      
      const [row, col] = empty;
      let count = 0;
      
      for (let num = 1; num <= 9; num++) {
        if (isValid(grid, row, col, num)) {
          grid[row][col] = num;
          count += countSolutions(grid, limit - count);
          grid[row][col] = 0;
          if (count >= limit) return count;
        }
      }
      return count;
    }

    function shuffle(arr) {
      const a = [...arr];
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function newGame() {
      solution = generateSudoku();
      board = solution.map(row => [...row]);
      given = Array(9).fill(null).map(() => Array(9).fill(true));
      
      // Remove numbers based on difficulty while ensuring unique solution
      const toRemove = removeCounts[difficulty];
      const positions = shuffle(getAllPositions());
      let removed = 0;
      
      for (const [r, c] of positions) {
        if (removed >= toRemove) break;
        
        const backup = board[r][c];
        board[r][c] = 0;
        given[r][c] = false;
        
        // Check if puzzle still has unique solution (for hard mode, skip this check for speed)
        if (difficulty !== 'hard') {
          const testGrid = board.map(row => [...row]);
          if (countSolutions(testGrid, 2) !== 1) {
            board[r][c] = backup;
            given[r][c] = true;
            continue;
          }
        }
        removed++;
      }

      selectedCell = null; errors = 0; gameOver = false;
      clearInterval(timerInterval); seconds = 0;
      document.getElementById('timer').textContent = '0:00';
      document.getElementById('errors').textContent = '0';
      updateBest();
      timerInterval = setInterval(() => {
        seconds++;
        const m = Math.floor(seconds / 60);
        const s = seconds % 60;
        document.getElementById('timer').textContent = `${m}:${s.toString().padStart(2, '0')}`;
      }, 1000);
      renderBoard();
      renderNumPad();
    }

    function getAllPositions() {
      const positions = [];
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          positions.push([r, c]);
        }
      }
      return positions;
    }

    function renderBoard() {
      const gridEl = document.getElementById('grid');
      gridEl.innerHTML = '';
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          if (given[r][c]) cell.classList.add('given');
          else if (board[r][c] !== 0) cell.classList.add('user-input');
          if (board[r][c] !== 0) cell.textContent = board[r][c];
          cell.dataset.r = r; cell.dataset.c = c;
          cell.addEventListener('click', () => selectCell(r, c));
          gridEl.appendChild(cell);
        }
      }
    }

    function renderNumPad() {
      const pad = document.getElementById('numPad');
      pad.innerHTML = '';
      for (let n = 1; n <= 9; n++) {
        const btn = document.createElement('button');
        btn.className = 'num-btn';
        btn.textContent = n;
        btn.addEventListener('click', () => placeNumber(n));
        pad.appendChild(btn);
      }
      const eraseBtn = document.createElement('button');
      eraseBtn.className = 'num-btn erase';
      eraseBtn.textContent = '‚å´';
      eraseBtn.addEventListener('click', () => placeNumber(0));
      pad.appendChild(eraseBtn);
    }

    function selectCell(r, c) {
      if (gameOver) return;
      selectedCell = { r, c };
      highlightCells();
    }

    function highlightCells() {
      document.querySelectorAll('.cell').forEach(cell => {
        cell.classList.remove('selected', 'same-num', 'error');
      });
      if (!selectedCell) return;
      const { r, c } = selectedCell;
      const selCell = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
      selCell.classList.add('selected');
      const num = board[r][c];
      if (num !== 0) {
        document.querySelectorAll('.cell').forEach(cell => {
          const cr = parseInt(cell.dataset.r);
          const cc = parseInt(cell.dataset.c);
          if (board[cr][cc] === num && !(cr === r && cc === c)) {
            cell.classList.add('same-num');
          }
        });
      }
    }

    function placeNumber(n) {
      if (gameOver || !selectedCell) return;
      const { r, c } = selectedCell;
      if (given[r][c]) return;
      
      if (n === 0) {
        board[r][c] = 0;
        playSound('place');
      } else if (n === solution[r][c]) {
        board[r][c] = n;
        playSound('place');
        checkWin();
      } else {
        board[r][c] = n;
        errors++;
        document.getElementById('errors').textContent = errors;
        playSound('error');
        if (errors >= 3) {
          gameOver = true;
          clearInterval(timerInterval);
          showModal(false);
          return;
        }
      }
      renderBoard();
      highlightCells();
    }

    function getHint() {
      if (gameOver) return;
      const empty = [];
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          if (board[r][c] === 0) empty.push({ r, c });
        }
      }
      if (empty.length === 0) return;
      const { r, c } = empty[Math.floor(Math.random() * empty.length)];
      board[r][c] = solution[r][c];
      given[r][c] = true;
      playSound('place');
      renderBoard();
      checkWin();
    }

    function checkWin() {
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          if (board[r][c] !== solution[r][c]) return;
        }
      }
      gameOver = true;
      clearInterval(timerInterval);
      playSound('win');
      createConfetti();
      if (!best[difficulty] || seconds < best[difficulty]) {
        best[difficulty] = seconds;
        localStorage.setItem('sudoku_best', JSON.stringify(best));
        updateBest();
      }
      showModal(true);
    }

    function updateBest() {
      const b = best[difficulty];
      if (b) {
        const m = Math.floor(b / 60);
        const s = b % 60;
        document.getElementById('best').textContent = `${m}:${s.toString().padStart(2, '0')}`;
      } else {
        document.getElementById('best').textContent = '-';
      }
    }

    function showModal(won) {
      document.getElementById('modalTitle').textContent = won ? 'üéâ Congratulations!' : 'üò¢ Game Over';
      const m = Math.floor(seconds / 60);
      const s = seconds % 60;
      document.getElementById('modalMsg').textContent = won ? `Time: ${m}:${s.toString().padStart(2, '0')}` : 'Too many errors!';
      const stars = document.querySelectorAll('#starRating .star');
      const starCount = won ? (errors === 0 ? 3 : errors === 1 ? 2 : 1) : 0;
      stars.forEach((st, i) => st.classList.toggle('filled', i < starCount));
      document.getElementById('modal').classList.add('show');
    }

    function closeModal() {
      document.getElementById('modal').classList.remove('show');
      newGame();
    }

    // Keyboard support
    document.addEventListener('keydown', (e) => {
      if (e.key >= '1' && e.key <= '9') placeNumber(parseInt(e.key));
      else if (e.key === 'Backspace' || e.key === 'Delete') placeNumber(0);
    });

    newGame();
  </script>
</body>
</html>